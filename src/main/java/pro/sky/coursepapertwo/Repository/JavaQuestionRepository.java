package pro.sky.coursepapertwo.Repository;

import org.springframework.stereotype.Repository;
import pro.sky.coursepapertwo.Exception.QuestionAlreadyAddedException;
import pro.sky.coursepapertwo.Model.Question;

import javax.annotation.PostConstruct;
import java.util.Collection;
import java.util.Set;

@Repository
public class JavaQuestionRepository implements QuestionRepository {

    private final Set<Question> questions;
    private long ID = 0;
    private final String ERR_NUMBER_QUESTION_ALREADY_HAVE = "Такой номер вопроса в списке уже есть!";
    private final String ERR_NUMBER_QUESTION_NOT_FOUND = "Такого номера вопроса не существует!";

    public JavaQuestionRepository(Set<Question> questions) {
        this.questions = questions;
    }

    public Set<Question> listOfQuestions() {
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое 'переменная'?</b></font>",
                "<font color='#32cd32'><b>Переменная — это ячейка в памяти компьютера, которой можно присвоить имя и в которой можно хранить данные.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>По каким параметрам переменные различаются?</b></font>",
                "<font color='#32cd32'><b>Переменные различаются по нескольким параметрам: какие данные хранятся в переменной, сколько данных хранится и сколько займет места в памяти компьютера сама переменная.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Перечислите типы переменных и действия, которые с ними можно осуществлять.</b></font>",
                "<font color='#32cd32'><b>Целочисленные типы — типы, которые содержат в себе целое число (без дробной части). Например, 1, −10, 100 и т. д. К ним относятся byte, short, int, long (в порядке возрастания размера ячейки и, соответственно, допустимых значений). Вещественные типы (типы с плавающей точкой) — типы, которые содержат в себе не только целую, но еще и дробную часть. Например, 2.5, 10.1, 125.8. К вещественным типам относятся float и double. Они, как и целочисленные, отличаются размером ячейки и расположены в строке выше по возрастанию, однако, помимо размера, вещественные типы отличаются допустимой «точностью»." +
                        "Логический тип переменных — тип, в котором хранится информация в формате true/false (т. е. истина/ложь). В основном используется двумя способами:" +
                        "1. В качестве маркера. Мы вручную кладем в переменную данного типа какое-то значение и во время работы программы можем его поменять в зависимости от каких-нибудь факторов (например, пользователь ввел некорректное значение и нам нужно завершить выполнение программы или ее части)." +
                        "2. В качестве результата какого-либо сравнения между двумя элементами/значениями. Например, нужно вычислить, является ли человек совершеннолетним." +
                        "Символьный тип переменных — тип переменной, в которой можно хранить закодированные данные. Другими словами, когда мы используем символьный тип переменной, то используем кодовые обозначения цифрами и/или буквами, а их настоящие значения можем найти в таблице ASCII.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что означает 'инициализация'?</b></font>",
                "<font color='#32cd32'><b>Инициализация — присваивание какого-то значения переменной.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие особенности инициализации вы можете назвать?</b></font>",
                "<font color='#32cd32'><b>В Java можно инициализировать переменную, если она является членом класса. Существует четыре способа инициализации членов данных класса:" +
                        "инициализация по умолчанию (неявная инициализация);" +
                        "явная инициализация начальными значениями (константными значениями);" +
                        "явная инициализация методами класса;" +
                        "инициализация с помощью конструкторов классов.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие условные операторы вы знаете? Дайте краткое определение каждому из них.</b></font>",
                "<font color='#32cd32'><b>Конструкция if(). Для вызова условного оператора мы используем конструкцию  if (здесь, в скобках, пишем условие, которое должно получить true напрямую или в результате сравнения данных). Для того, чтобы блок внутри if сработал, нам необходимо любым способом передать в скобки значение true. В случае false блок выполнен не будет." +
                        "Конструкция else. Она представляет собой аналог второго if(), но не требует дополнительного условия выполнения, так как выполняется в тот момент, когда основной блок if() получил в условие значение false и сработать не смог." +
                        "Конструкция if-else if-else. Эта конструкция добавляет возможность проверить еще одно условие и при этом не добавляет вложенности." +
                        "Конструкция switch. В этой конструкции мы объявляем 'случаи' (блоки case), которые выполняются при совпадении значения переменной и определенного 'случая'.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое 'цикл'?</b></font>",
                "<font color='#32cd32'><b>Цикл — конструкция языка, позволяющая выполнять один и тот же код многократно в зависимости от условий.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие циклы вы знаете, в чем их отличия?</b></font>",
                "<font color='#32cd32'><b>Цикл while. Этот цикл создан для того, чтобы выполнять свой блок кода в случае true в блоке условий. Он выглядит как if, но если if выполняется один раз, while выполняется бесконечно, пока условие корректно." +
                        "Цикл do-while. Цикл do-while является продолжением развития идеи, которую реализует while. Отличие в том, что while может выполниться 0 раз (если условие изначально равняется false), а цикл do-while выполнится минимум 1 раз. Это достигается тем, что цикл while сначала проверяет условие в скобках и затем выполняет блок, а do-while сначала запускает блок, а потом проверяет условие." +
                        "Цикл for. Он в своих скобках имеет три блока. Первый условный блок осуществляет инициализацию данных, которые будут доступны только в цикле. Он будет запущен перед началом выполнения цикла. Второй условный блок осуществляет проверку условия (он идентичен работе условий в while и if). Выполняется перед каждым шагом цикла. Третий условный блок осуществляет действия, исполняемые после шага цикла, но до проверки условия для выполнения следующего шага. Выполняется в конце каждого шага цикла перед запуском блока 2.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что вы знаете о массивах?</b></font>",
                "<font color='#32cd32'><b>Массив — упорядоченная структура данных фиксированного размера. Массив позволяет создать последовательность данных определенного типа заранее известной длины. Массив является объектом.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Дайте определение строке</b></font>",
                "<font color='#32cd32'><b>Строка — неизменяемый массив символов. Также строки, как и массивы, являются объектами, и если им не присвоить значение (инициализировать), они будут содержать в себе null.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие основные свойства строки вы знаете?</b></font>",
                "<font color='#32cd32'><b>Сравнение строк. При необходимости сравнить строки мы используем метод equals, который в качестве параметра принимает другую строку и возвращает true/false." +
                        "Размер строки. Так как строка внутри является массивом символов, кажется логичным, что у нее должна быть переменная length, хранящая длину. Чтобы обратиться не к свойству, а к методу, нужно добавить круглые скобки.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое 'метод'?</b></font>",
                "<font color='#32cd32'><b>Метод — блок кода, который выполняет определенную функцию и позволяет себя переиспользовать в нескольких местах без необходимости снова и снова писать один и тот же код.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Методы каких типов бывают? Приведите примеры использования каждого типа.</b></font>",
                "<font color='#32cd32'><b>Статические — методы, которые принадлежат классу. Т. е. вам не требуется иметь объект для его вызова. Пример: Arrays.toString() или любой другой метод сущности Arrays. Как мы помним наш опыт использования методов Arrays, нам не требуется никаких дополнительных манипуляций. Мы просто пишем слово Arrays, что является классом, а затем у этого класса вызываем нужный метод. По сути, это просто код без привязки к какому-то объекту, который просто сгруппирован внутри Arrays, а все необходимые данные мы передаем ему в скобках в виде параметра метода." +
                        "Нестатические — методы, которые принадлежат объекту. Для их использования нам нужно самим создать объект, инициализировать его и вызвать у этого объекта метод. Обычно эти методы работают с данными конкретного объекта, который их вызывает. Например, когда мы создаем строку и вызываем метод toUpperCase, этот метод срабатывает именно с той строкой, которая вызвала этот метод. Нам не требуется передавать ему какие-то параметры в скобках, так как он уже имеет все данные из объекта, который его вызывает.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое класс? Какие отличительные особенности классов вы можете выделить?</b></font>",
                "<font color='#32cd32'><b>Это сущность, которая описывает состояние (переменные), поведение (методы) и способы создания своих объектов (если они подразумеваются). Классы бывают разных типов, и вот несколько из них:" +
                        "Хранитель данных (обычно эти классы не имеют «умений» и созданы только для агрегации в себе некоторых данных)." +
                        "Утилити-класс (обычно эти классы имеют только «умения» и созданы для работы с другими объектами, например класс Arrays и массивы)." +
                        "Самодостаточные классы (как String), которые имеют и состояние (массив символов, в виде которого хранятся данные строки), и поведение (методы, которые с этим состоянием работают, как replace, например).</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое объект? Что связывает классы и объекты?</b></font>",
                "<font color='#32cd32'><b>Всё, что выглядит немного сложнее и/или умеет немного больше, чем просто цифра или символ, будет являться объектом. Объекты имеют как состояние (характеристики или свойства), так и поведение (умения, навыки или просто методы)." +
                        "Класс представляет собой план, по которому собирается объект. Также класс содержит все общие свойства, которые не могут отличаться у любых объектов. Объект же является тем самым результатом. И он тоже может хранить свои характеристики, которые будут уникальными только для него или для нескольких объектов из общей массы.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие методы объектов вам известны? Для каких целей предназначены данные методы?</b></font>",
                "<font color='#32cd32'><b>В Java есть несколько методов, которые принято объявлять в любом классе, который хранит в себе какие-то данные. Эти методы нестатические (так как должны работать с данными из полей конкретного объекта) и имеют строгую сигнатуру. Таких методов три:" +
                        "1. toString. Метод toString используется для приведения нашего объекта к строковому виду. В нем мы должны вернуть строку в том формате, в котором хотим видеть наш объект в печати." +
                        "2. equals. Его задача — сравнивать объекты. Метод equals нам позволяет считать объекты равными, если совпадают те данные этих объектов, которые нужны нам." +
                        "3. hashCode. Этот метод выполняет функцию превращения объекта в число (кодировки). Т. е. он должен анализировать данные объекта (которые вы выберете) и на основе некой магической хеш-функции превращать эти данные в числа, а затем с помощью математической магии превращать их в единственное число типа int, которое и является хеш-кодом нашего объекта. Если данные изменяются, хеш-код должен пересчитываться.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Расскажите о переменных примитивного и ссылочного типа? В чём различия данных переменных?</b></font>",
                "<font color='#32cd32'><b>Примитивы содержат в себе одно значение и не более. За счет этого они имеют заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко." +
                        "Все остальные типы являются ссылочными, т. е. объектными. Например, массивы и строки. Объекты могут хранить в себе как какие-то данные (в виде полей), так и методы по работе с ними." +
                        "Переменные примитивного типа хранят в себе данные, а объекты хранят в себе ссылки на данные из области паямти.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Какие составные части памяти в Java вы можете выделить? Дайте определения и опишите основные особенности частей памяти.</b></font>",
                "<font color='#32cd32'><b>Стек и куча (Stack и Heap). Стек, простыми словами, представляет собой массив. Он состоит из ячеек, имеет определенный размер (количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной ячейке происходит за константное время." +
                        "Куча (Heap). Куча представляет собой место, где хранятся все ваши объекты. Даже если объект хранит в себе поле примитивного типа, данные из этого поля будут привязаны к вашему объекту и помещены в кучу вместе с ним. Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется «сборщик мусора» (garbage collector), а сам процесс, как ни странно, называется «сборка мусора» (garbage collection).</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Опишите жизненный цикл приложения.</b></font>",
                "<font color='#32cd32'><b>Первым делом происходит сборка проекта. В этот момент IDEA подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода. На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке, что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата class. Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много красного текста в вашей консоли." +
                        "В тот момент, когда все необходимые файлы формата class сформированы, а формируются они в таком соотношении: 1 Java-файл преобразуется в 1 class-файл — JVM получает возможность запустить ваш код. JVM (Java Virtual Machine) в упрощенном представлении является программой, которая читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор. Именно за счет JVM у приложений на Java появилась одна из киллер фич, а именно: мультиплатформенность. Компилятор может быть один, его задача — сформировать на основе Java-кода байт-код и записать его в class-файлы.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое полиморфизм? Дайте определение и опишите основные особенности данного принципа ООП</b></font>",
                "<font color='#32cd32'><b>Данный принцип описывает механизм работы с разными типами объектов как с одним. Т. е. если наши объекты имеют какого-то общего 'родственника', мы можем объединить их в массив и работать с ними так, как будто работаем с их общим родителем. Полиморфизм позваляет перегружать одноименные методы родительского класса в классах-потомках, то есть название метода остается прежним, а его 'начинка' изменяется под нужды конкретного класса.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое наследование? Дайте определение и опишите основные особенности данного принципа ООП</b></font>",
                "<font color='#32cd32'><b>Этот принцип описывает механизм, позволяющий писать новый класс на основе уже имеющегося функционала в другом классе без необходимости дублировать его у себя в реализации. Наследование позваляет создать новый класс на основе уже существующего: к свойствам и методам класса-родителя добавляем собственные свойства/методы.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое абстракция? Дайте определение и опишите основные особенности данного принципа ООП</b></font>",
                "<font color='#32cd32'><b>Если класс является абстрактным, это позволяет нам объявить внутри него абстрактные методы. Это методы, которые мы объявляем, но реализацию не пишем. Важно запомнить, что обычный класс не может иметь абстрактных методов. Это значит, что любой класс, который наследует абстрактный класс с абстрактными методами, обязан их реализовать внутри себя. Или тоже стать абстрактным.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое инкапсуляция? Дайте определение и опишите основные особенности данного принципа ООП</b></font>",
                "<font color='#32cd32'><b>Инкапсуляция в Java подразумевает разграничение доступа к данным и возможностям классов и объектов. Реализуется инкапсуляция в Java с помощью модификаторов доступа (public, protected, default (пустой) и private), а также с помощью геттеров и сеттеров.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое интерфейс и в каких ситуациях он применяется?</b></font>",
                "<font color='#32cd32'><b>Может сложиться ситуация, когда есть какая-то группа классов, что имеют общую функциональность, но общих полей и кода они не имеют. Как нам можно группировать их? Для таких ситуаций используются интерфейсы. Заметьте, что с интерфейсом наш класс мы связываем через ключевое слово implements (реализует). Множественная реализация в Java разрешена.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Дайте определение понятию 'исключения'. Какие типы исключений вам известны? В чем их основные особенности?</b></font>",
                "<font color='#32cd32'><b>Исключения - ситуации, когда в работе программы что-то пошло не так." +
                        "Непроверяемые исключения. Непроверяемые исключения являются прямыми наследниками класса RuntimeException. Это те исключения, которые возникают в момент выполнения приложения." +
                        "Проверяемые исключения. Проверяемые исключения являются прямыми наследниками класса Exception. Это те исключения, которые могут быть предсказаны на момент написания кода, следовательно, Java потребует от вас их обработать или «прокинуть» методу выше по цепочке вызовов.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Расскажите об иерархии ошибок.</b></font>",
                "<font color='#32cd32'><b>В Java существует целая иерархия ошибок. Во главе всего стоит Throwable. Этот класс является родителем всего «выбрасываемого» в Java, т. е. всех ошибок. Далее эти самые ошибки делятся на две больших группы." +
                        "1. Error (ошибка). Представляют собой критические ошибки, возникающие в тех случаях, когда кончается память в куче, переполняется стек (как мы помним, стек имеет определенный размер) в случае некорректной рекурсии (бесконечный вызов методом самого себя), и другие ошибки JVM. Эти ошибки могут вылететь в любой момент, следовательно, пытаться их отловить где-то в коде возможно, но не имеет смысла." +
                        "2. Exception (исключение). Представляют собой ошибки, которые напрямую связаны с кодом. Именно их выкидывает код в случае некорректных данных, отсутствующих данных, разрыва соединения с сервером, некорректного запроса к базе данных (ошибка в SQL-запросе), выходе за пределы массива, обращение к null в качестве объекта, делении на 0 и т. д.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое коллекции? Какие основные типы коллекций вам известны?</b></font>",
                "<font color='#32cd32'><b>Коллекции являются более высокоуровневыми абстракциями над каким-то типом хранилища. В зависимости от задач они могут хранить свои данные в массиве (как String, который тоже хранит внутри массив символов) или связывать объекты друг с другом, создавая таким образом определенный порядок. Или вообще не иметь порядок, представляя собой что-то вроде «кучи» или «мешанины» из объектов. Коллекции обычно сами следят за своим актуальным размером (количеством заполненных ячеек или связанных объектов), сами расширяются (в случае структур на базе массивов) при определенном проценте заполнения внутреннего хранилища и имеют множество других полезных функций. Также коллекции можно печатать без необходимости оборачивать во что-то, как было с Arrays.toString, ведь коллекции являются объектами в привычном нам понимании, т. е. имеют свои методы." +
                        "Основными типами коллекций являются:" +
                        "1. Списки (листы)." +
                        "2. Множества (сеты)" +
                        "3. Словари (карты, ассоциативные массивы, мапы).</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое ArrayList? В каких ситуациях он используется? Какие операции могут быть совершены с ArrayList?</b></font>",
                "<font color='#32cd32'><b>Этот класс в качестве хранилища использует массив, который в случае недостатка элементов расширяется. Но так как массивы расширять нельзя, каждый раз, когда свободные ячейки заканчиваются, создается новый массив, равный 1,5 длины старого + 1 ячейка, а затем в него копируется содержимое старого массива." +
                        "Метод add добавит элемент в конец списка. Если необходимо добавить элемент в начало, то используется два набора параметров того же метода add. Первый параметр в данном случае является индексом. Чтобы получить элемент из списка, нужно вызвать метод get. Если нам нужно заменить элемент по определенному индексу, на помощь приходит метод set. Получить количество элементов списка можно с помощью метода size. С помощью метода contains можно определить, имеется ли элемент в списке. Удалить элемент из списка можно методом remove.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое ассоциативный массив? Какие операции могут быть совершены с данным массивом?</b></font>",
                "<font color='#32cd32'><b>Переходим к самой сложной с точки зрения реализации структуре данных. В ней совмещены реализации двух листов, а еще присутствует самобалансирующееся дерево. Дерево позволяет искать элементы быстрее, так как располагает их в порядке увеличения/уменьшения хеш-кода. И вы проверите значительно меньше элементов для нахождения нужного." +
                        "Операции с ассоциативным массивом: добавление элементов, удаление элементов, поиск и получение элемента.</b></font>"));
        questions.add(new Question(++ID, "<font color='#cc0000'><b>Что такое HashMap и HashSet? Как связаны данные понятия?</b></font>",
                "<font color='#32cd32'><b>HashSet. Это множество, которое анализирует хеш-код вашего элемента, в зависимости от него выбирает нужную ячейку в массиве и укладывает туда элемент. Создается так же, как списки, но уже с помощью интерфейса Set." +
                        "HashMap. Это хранилище по принципу ключ-значение, где ключи уникальны, а значения могут повторяться. Как видно из названия, построена она на том же hashCode, что и HashSet. Это значит, что ключами должны быть неизменяемые объекты, ведь при изменении состояния объекта (значений в его полях и тому подобное) меняется и hashCode, а значит, мы теряем возможность быстро найти этот элемент в коллекции, ведь он был добавлен в хранилище по одному хеш-коду, а после изменения состояния объекта поиск будет идти по другому хеш-коду.</b></font>"));

        return questions;
    }

    @Override
    public Question add(Question question) throws QuestionAlreadyAddedException {
        if (questions.contains(question.getId())) {
            throw new QuestionAlreadyAddedException(ERR_NUMBER_QUESTION_ALREADY_HAVE);
        }
        question.setId(++ID);
        questions.add(question);
        return question;
    }

    @Override
    public Question remove(Question question) {
        questions.remove(question);
        return question;
    }

    @Override
    public Collection<Question> getAll() {
        return listOfQuestions();
    }

    @PostConstruct
    public void init() {
        System.out.println("Репозиторий по java создан!");
    }
}
